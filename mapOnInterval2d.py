from __future__ import division
import numpy as np
import matplotlib.pyplot as plt
from math import sin, cos, pi, sqrt, log, pi
import haarWavelet2d as hW
from scipy.interpolate import RectBivariateSpline
import scipy

""" This is a class modelling maps on the square [0,1]x[0,1]. There are four ways of defining a function: 
	 	-> By explicit discretization values on a grid over [0,1], 
		-> by fourier expansion ([a00, a01, a02, b01, b02; a10, a11, a12, ...]) means a00 + a01*cos(pi*x) + a02*cos(2*pi*x) + b01*sin(pi*x) + b02*sin(2*pi*x) + a10*cos(pi*y) + a11*cos(pi*x)*cos(pi*y) + a12*cos(2*pi*x)*cos(pi*y) + ...
		-> by wavelet expansion as used in haarWavelet2d.py
		-> by function handle
	Missing information is calculated from the defining parameter (fourier is the exception so far)
"""

class mapOnInterval():
	def __init__(self, inittype, param, numSpatialPoints=2**7, interpolationdegree=3):
		# there are three possibilities of initializing a mapOnInterval instance:
		# 1) By explicit values on a discretization: inittype == "expl"
		# 2) By Fourier expansion: inittype == "fourier"
		# 3) By Haar Wavelet expansion: inittype == "wavelet"
		self._values = None
		self._fouriermodes = None
		self._waveletcoeffs = None
		self.interpolationdegree = interpolationdegree
		self._handle = None
		self._memo = {}
		self.inittype = inittype
		self.numSpatialPoints = numSpatialPoints
		self.resol = None
		
		if inittype == "expl": # no Fourier expansion!
			self._values = param
			#self.waveletcoeffs = hW.waveletanalysis(self.values)
			#self._handle = InterpolatedUnivariateSpline(np.linspace(0, 1, len(self.values), endpoint=False), self.values, k=3, ext=3)
		elif inittype == "fourier":
			self._fouriermodes = param # odd cardinality!!
			#self._values = evalmodes(self.fouriermodes, np.linspace(0, 1, numSpatialPoints, endpoint=False))
			#self._waveletcoeffs = hW.waveletanalysis(self.values)
			self._handle = lambda x, y: evalmodes(self.fouriermodes, x, y)
		elif inittype == "wavelet": # no Fourier expansion!
			self._waveletcoeffs = param
			#self._values = hW.waveletsynthesis(self.waveletcoeffs)
			#self.handle = InterpolatedUnivariateSpline(np.linspace(0, 1, len(self.values), endpoint=False), self.values, k=3, ext=3)
		elif inittype == "handle":
			self._handle = param
			#self._values = self.handle(np.linspace(0, 1, numSpatialPoints, endpoint=False))
			#self.waveletcoeffs = hW.waveletanalysis(self.values)
		else:
			raise ValueError("inittype neither expl nor fourier nor wavelet")
		
		# The next four properties manage the variables values, fouriermodes, waveletcoeffs and handle: As each instance of an moi is generated by one of those, the others might be empty and might still need to be calculated
		
	@property
	def values(self):
		if self._values is None: # property not there yet, get from initialization data
			if self.inittype == "fourier":
				self._values = evalmodesGrid(self.fouriermodes, np.linspace(0, 1, self.numSpatialPoints, endpoint=False))
			elif self.inittype == "wavelet":
				self._values = hW.waveletsynthesis2d(self.waveletcoeffs, resol=self.resol)
			elif self.inittype == "handle":
				x = np.linspace(0, 1, self.numSpatialPoints, endpoint=False)
				X, Y = np.meshgrid(x, x)
				
				self._values = self.handle(X, Y)
			else:
				raise Exception("Wrong value for self.inittype")
			return self._values
		else:
			return self._values
	
	@property
	def fouriermodes(self):
		if self._fouriermodes is None:
			if self.inittype == "expl":
				raise NotImplementedError("(expl -> fourier) not yet implemented")
			elif self.inittype == "wavelet":
				raise NotImplementedError("(wavelet -> fourier) not yet implemented")
			elif self.inittype == "handle":
				raise NotImplementedError("(handle -> fourier) not yet implemented")
			else:
				raise Exception("Wrong value for self.inittype")
			return self._fouriermodes
		else:
			return self._fouriermodes
			
	@property
	def waveletcoeffs(self):
		if self._waveletcoeffs is None:
			if self.inittype == "expl":
				self._waveletcoeffs = hW.waveletanalysis2d(self.values)
			elif self.inittype == "fourier":
				self._waveletcoeffs = hW.waveletanalysis2d(self.values)
			elif self.inittype == "handle":
				self._waveletcoeffs = hW.waveletanalysis2d(self.values)
			else:
				raise Exception("Wrong value for self.inittype")
			return self._waveletcoeffs
		else:
			return self._waveletcoeffs		
	
	@property
	def handle(self):
		if self._handle is None:
			if self.inittype == "expl":
				 self._interp = RectBivariateSpline(np.linspace(0, 1, len(self.values), endpoint=False), np.linspace(0, 1, len(self.values), endpoint=False), self.values, kx=self.interpolationdegree, ky=self.interpolationdegree)
				 self._handle = lambda x, y: self._interp.ev(y, x)
			elif self.inittype == "fourier":
				self._handle = lambda x, y: evalmodes(self.fouriermodes, x, y)
			elif self.inittype == "wavelet":
				 self._interp = RectBivariateSpline(np.linspace(0, 1, len(self.values), endpoint=False), np.linspace(0, 1, len(self.values), endpoint=False), self.values, kx=self.interpolationdegree, ky=self.interpolationdegree)
				 #self._handle = lambda x: self.evaluateInterp(self._interp, x)
				 # new version:
				 # WOAH, for some reason we need to swap x and y here?
				 self._handle = lambda x, y: self._interp.ev(y, x)
			else:
				raise Exception("Wrong value for self.inittype")
			return self._handle
		else:
			return self._handle
	
	def handlememo(self, val):
		assert(isinstance(val, np.ndarray))
		assert(val.ndim == 1)
		return self.handle(val)
			
	def evaluateInterp(self, interp, x):
	 	assert (isinstance(x, np.ndarray))
	 	if x.ndim == 2:
	 		print("2 dimensions")
	 		assert(x.shape[0] == 2)
	 		return interp.ev(x[0,:], x[1,:])
	 	else:
	 		print("1 dimension")
	 		return interp.ev(x[0], x[1])
	
	def getX(self):
		return np.linspace(0, 1, self.numSpatialPoints, endpoint=False)
	
	# overloading of basic arithmetic operations, in order to facilitate f + g, f*3 etc. for f,g mapOnInterval instances
	def __add__(self, m):
		if isinstance(m, mapOnInterval): # case f + g
			if self.inittype == "fourier":
				if m.inittype == "fourier":
					return mapOnInterval("fourier", self.fouriermodes + m.fouriermodes)
				else:
					return mapOnInterval("expl", self.values + m.values)
			elif self.inittype == "expl":
				return mapOnInterval("expl", self.values + m.values)
			elif self.inittype == "wavelet":
				if m.inittype == "wavelet":
					return mapOnInterval("wavelet", [w1 + w2 for w1, w2 in zip(self.waveletcoeffs, m.waveletcoeffs)])
			elif self.inittype == "handle":
				if m.inittype == "fourier" or m.inittype == "handle":
					return mapOnInterval("handle", lambda x: self.handle(x) + m.handle(x))
			else:
				raise Exception("Wrong value for self.inittype in __add__")
		else: # case f + number
			if self.inittype == "handle":
				return mapOnInterval("handle", lambda x: self.handle(x) + m)
			else:
				return mapOnInterval("expl", self.values + m)
	
	def __sub__(self, m):
		if isinstance(m, mapOnInterval): # case f - g
			if self.inittype == "fourier":
				if m.inittype == "fourier":
					return mapOnInterval("fourier", self.fouriermodes - m.fouriermodes)
				else:
					return mapOnInterval("expl", self.values - m.values)
			elif self.inittype == "expl":
				return mapOnInterval("expl", self.values - m.values)
			elif self.inittype == "wavelet":
				if m.inittype == "wavelet":
					return mapOnInterval("wavelet", [w1 - w2 for w1, w2 in zip(self.waveletcoeffs, m.waveletcoeffs)])
			elif self.inittype == "handle":
				if m.inittype == "fourier" or m.inittype == "handle":
					return mapOnInterval("handle", lambda x: self.handle(x) - m.handle(x))
			else:
				raise Exception("Wrong value for self.inittype in __add__")
		else: # case f - number
			if self.inittype == "handle":
				return mapOnInterval("handle", lambda x: self.handle(x) - m)
			else:
				return mapOnInterval("expl", self.values - m)
	
	def __mul__(self, m):
		if isinstance(m, mapOnInterval): # case f * g
			if self.inittype == "fourier":
				return mapOnInterval("expl", self.values * m.values)
			elif self.inittype == "expl":
				return mapOnInterval("expl", self.values * m.values)
			elif self.inittype == "wavelet":
				return mapOnInterval("expl", self.values * m.values)
			elif self.inittype == "handle":
				if m.inittype == "fourier" or m.inittype == "handle":
					return mapOnInterval("handle", lambda x: self.handle(x) * m.handle(x))
			else:
				raise Exception("Wrong value for self.inittype in __add__")
		else: # case f * number
			if self.inittype == "handle":
				return mapOnInterval("handle", lambda x: self.handle(x) * m)
			elif self.inittype == "wavelet":
				return mapOnInterval("wavelet", [w1 * m for w1 in self.waveletcoeffs])
			elif self.inittype == "fourier":
				return mapOnInterval("fourier", [fm * m for fm in self.fouriermodes])
			else:
				return mapOnInterval("expl", self.values * m)
	def __div__(self, m):
		raise Exception("use f * 1/number for f/number")
	def __truediv__(self, m):
		return self.__div__(m)
			


"""def integrate(x, f, primitive=True): 
	# integrates fncvals over x, returns primitive if primitive==True and integral over x if primitive==False
	if isinstance(f, mapOnInterval):
		fncvals = f.values
	else: 
		raise Exception()
	assert(len(x) == len(fncvals))
	delx = x[1]-x[0]
	if not primitive:
		return np.trapz(f.values, dx=delx)
"""
#res = np.zeros_like(fncvals)

#res[0] = fncvals[0]*delx # should not be used for plotting etc. but is needed for compatibility with differentiate
#for i, val in enumerate(x[1:]): # this is slow!
#	y = np.trapz(fncvals[0:i+2], dx=delx)
#	res[i+1] = y
"""
	res = np.concatenate((np.array([0]), scipy.integrate.cumtrapz(fncvals, x, dx = delx)))
	return mapOnInterval("expl", res)
	
def differentiate(x, f): # finite differences
	if isinstance(f, mapOnInterval):
		fncvals = f.values
	else:
		raise Exception()
	fprime = np.zeros_like(fncvals)
	fprime[1:] = (fncvals[1:]-fncvals[:-1])/(x[1]-x[0])
	fprime[0] = fprime[1]
	return mapOnInterval("expl", fprime)"""
def evalmodesGrid(modesmat, x):
	if not isinstance(x, np.ndarray):
		x = np.array([[x]])
	# evaluates fourier space decomposition in state space
	N = modesmat.shape[0]
	maxMode = N//2
	freqs = np.reshape(np.linspace(1, maxMode, N/2), (-1, 1))
	#x = np.reshape(x, (1, -1))
	M = len(x)
	phi_mat = np.zeros((M, M, N, N))
	X, Y = np.meshgrid(x, x)
	for k in range(N):
		for l in range(N):
			if k == 0 and l == 0:
				phi_mat[:, :, 0, 0] = np.ones((M,M))
			elif k == 0 and l > 0 and l <= maxMode:
				phi_mat[:, :, k, l] = np.cos(l*2*pi*X)
			elif k == 0 and l > 0 and l > maxMode:
				phi_mat[:, :, k, l] = np.sin((l-maxMode)*2*pi*X)
			elif k > 0 and k <= maxMode and l == 0:
				phi_mat[:, :, k, l] = np.cos(k*2*pi*Y)
			elif k > 0 and k > maxMode and l == 0:
				phi_mat[:, :, k, l] = np.sin((k-maxMode)*2*pi*Y)
			elif k > 0 and l > 0:
				if k <= maxMode and l <= maxMode:
					phi_mat[:, :, k, l] = np.cos(k*2*pi*Y)*np.cos(l*2*pi*X)
				elif k <= maxMode and l > maxMode:
					phi_mat[:, :, k, l] = np.cos(k*2*pi*Y)*np.sin((l-maxMode)*2*pi*X)
				elif k > maxMode and l <= maxMode:
					phi_mat[:, :, k, l] = np.sin((k-maxMode)*2*pi*Y)*np.cos(l*2*pi*X)
				else:
					phi_mat[:, :, k, l] = np.sin((k-maxMode)*2*pi*Y)*np.sin((l-maxMode)*2*pi*X)
	mm = np.reshape(modesmat, (1, 1, N, N))
	mm = np.tile(mm, (M, M, 1, 1))
	temp = mm*phi_mat
	return np.sum(temp, (2,3))

def evalmodes(modesmat, x, y):
	# input: x, y = x0, y0 or
	# 			x, y = np.array([x0, x1, ... , xM]), np.array([y0, y1, ... , yM])
	
	if (isinstance(x, (int, float)) or (isinstance(x, np.ndarray) and len(x) == 1)):
		N = modesmat.shape[0]
		maxMode = N//2
		freqs = np.reshape(np.linspace(1, maxMode, N/2), (-1, 1))
		phi_mat = np.zeros((N, N))
		for k in range(N):
			for l in range(N):
				if k == 0 and l == 0:
					phi_mat[0, 0] = 1
				elif k == 0 and l > 0 and l <= maxMode:
					phi_mat[k, l] = np.cos(l*2*pi*x)
				elif k == 0 and l > 0 and l > maxMode:
					phi_mat[k, l] = np.sin((l-maxMode)*2*pi*x)
				elif k > 0 and k <= maxMode and l == 0:
					phi_mat[k, l] = np.cos(k*2*pi*y)
				elif k > 0 and k > maxMode and l == 0:
					phi_mat[k, l] = np.sin((k-maxMode)*2*pi*y)
				elif k > 0 and l > 0:
					if k <= maxMode and l <= maxMode:
						phi_mat[k, l] = np.cos(k*2*pi*y)*np.cos(l*2*pi*x)
					elif k <= maxMode and l > maxMode:
						phi_mat[k, l] = np.cos(k*2*pi*y)*np.sin((l-maxMode)*2*pi*x)
					elif k > maxMode and l <= maxMode:
						phi_mat[k, l] = np.sin((k-maxMode)*2*pi*y)*np.cos(l*2*pi*x)
					else:
						phi_mat[k, l] = np.sin((k-maxMode)*2*pi*y)*np.sin((l-maxMode)*2*pi*x)
		temp = modesmat*phi_mat
		return np.sum(temp)
	else:		
		# evaluates fourier space decomposition in state space
		N = modesmat.shape[0]
		maxMode = N//2
		freqs = np.reshape(np.linspace(1, maxMode, N/2), (-1, 1))
		#x = np.reshape(x, (1, -1))
		M = x.shape[0]
		phi_mat = np.zeros((M, N, N))
		for k in range(N):
			for l in range(N):
				if k == 0 and l == 0:
					phi_mat[:, 0, 0] = np.ones((M,))
				elif k == 0 and l > 0 and l <= maxMode:
					phi_mat[:, k, l] = np.cos(l*2*pi*x)
				elif k == 0 and l > 0 and l > maxMode:
					phi_mat[:, k, l] = np.sin((l-maxMode)*2*pi*x)
				elif k > 0 and k <= maxMode and l == 0:
					phi_mat[:, k, l] = np.cos(k*2*pi*y)
				elif k > 0 and k > maxMode and l == 0:
					phi_mat[:, k, l] = np.sin((k-maxMode)*2*pi*y)
				elif k > 0 and l > 0:
					if k <= maxMode and l <= maxMode:
						phi_mat[:, k, l] = np.cos(k*2*pi*y)*np.cos(l*2*pi*x)
					elif k <= maxMode and l > maxMode:
						phi_mat[:, k, l] = np.cos(k*2*pi*y)*np.sin((l-maxMode)*2*pi*x)
					elif k > maxMode and l <= maxMode:
						phi_mat[:, k, l] = np.sin((k-maxMode)*2*pi*y)*np.cos(l*2*pi*x)
					else:
						phi_mat[:, k, l] = np.sin((k-maxMode)*2*pi*y)*np.sin((l-maxMode)*2*pi*x)
		mm = np.reshape(modesmat, (1, N, N))
		mm = np.tile(mm, (M, 1, 1))
		temp = mm*phi_mat
		return np.sum(temp, (1,2))
	
if __name__ == "__main__":
	"""x = np.linspace(0, 1, 2**9, endpoint=False)
	f1 = mapOnInterval("fourier", [0,0,1,0,1], 2**9)
	#plt.ion()
	#plt.plot(x, f1.values)
	#hW.plotApprox(x, f1.waveletcoeffs)
	
	f2 = mapOnInterval("expl", np.array([4,2,3,1,2,3,4,5]), 4)
	#hW.plotApprox(x, f2.waveletcoeffs)
	
	f3 = mapOnInterval("handle", lambda x: sin(3*x)-x**2*cos(x))
	#hW.plotApprox(x, f3.waveletcoeffs)
	
	
	hW.plotApprox(x, (f1*f3).waveletcoeffs)
	plt.show()"""
	"""modesmat = np.array([[1,0,1],[1,0,0],[0,-1,0]])
	modesmat = np.random.uniform(-1, 1, (11,11))
	J = 5
	x = np.linspace(0, 1, 2**J)
	f = evalmodesGrid(modesmat, x)
	plt.imshow(f, interpolation='None')
	plt.ion()
	plt.show()
	plt.figure()
	X, Y = np.meshgrid(x,x)
	Z = 1 + np.sin(2*pi*X) + np.cos(2*pi*Y) - np.cos(2*pi*X)*np.sin(2*pi*Y)
	plt.imshow(Z, interpolation='None')
	
	fun = mapOnInterval("fourier", modesmat)
	
	# test evaluation speed
	pts = np.random.uniform(0, 1, (2, 10))"""
	import measures as mm
	import time
	"""fun = mm.GaussianFourier2d(np.zeros((31,31)), 2., 0.5).sample()
	N = 2000
	pts = np.random.uniform(0, 1, (2, N))
	val = np.zeros((N,))
	start = time.time()
	ptseval = fun.handle(pts[0, :], pts[1, :])
	end = time.time()
	#for k in range(N):
	#	val[k] = fun.handle(pts[:, k])
	end2 = time.time()
	print(end-start)
	print(end2-end)"""
	fun = mm.GeneralizedGaussianWavelet2d(1.0, 1.0, 3, resol = 6).sample()
	
		
	
	
